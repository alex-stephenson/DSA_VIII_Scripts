dir_path <- paste0("clogs/", FO_names[i, 1])
if (!dir.exists(dir_path)) {
dir.create(dir_path, recursive = TRUE)
}
}
cleaning_log %>% purrr::map(~ create_xlsx_cleaning_log(.[],
cleaning_log_name = "cleaning_log",
change_type_col = "change_type",
column_for_color = "check_binding",
header_front_size = 10,
header_front_color = "#FFFFFF",
header_fill_color = "#ee5859",
header_front = "Calibri",
body_front = "Calibri",
body_front_size = 10,
use_dropdown = F,
sm_dropdown_type = "numerical",
kobo_survey = questions,
kobo_choices = choices,
output_path = paste0("clogs/",
unique(.[]$checked_dataset$Responsible_FO),
"/cleaning_log_",
unique(.[]$checked_dataset$Responsible_FO),
"_",
date_time_now,
".xlsx")))
# make copies of the clogs for archive purposes
#cleaning_log %>% purrr::map(~ create_xlsx_cleaning_log(.[],
#                                                       cleaning_log_name = "cleaning_log",
#                                                       change_type_col = "change_type",
#                                                       column_for_color = "check_binding",
#                                                       header_front_size = 10,
#                                                       header_front_color = "#FFFFFF",
#                                                       header_fill_color = "#ee5859",
#                                                       header_front = "Calibri",
#                                                       body_front = "Calibri",
#                                                       body_front_size = 10,
#                                                       use_dropdown = F,
#                                                       sm_dropdown_type = "numerical",
#                                                       kobo_survey = kobo_survey,
#                                                       kobo_choices = kobo_choice,
#                                                       output_path = paste0("04_data_cleaning/_clean_files_for_archive/cleaning_log_",
#                                                                            unique(.[]$checked_dataset$fo_in_charge_for_code),
#                                                                            "_",
#                                                                            date_time_now,
#                                                                            ".xlsx")
#)
#)
#each KI will be asked if they have other potential contacts for the DSA, those are grouped by FO similar to the clogs
contact_data_by_fo <- group_by_fo %>%
#  mutate(referral_yn = sample(c("yes", "no"), size = nrow(.), replace = TRUE)) %>%
dplyr::group_split() %>%
purrr::map(~ filter(., referral_yn == "Yes") %>%
select(Responsible_FO, idp_code, district_name, ki_name, referral_name, referral_phone)
)
### make the file directories if required for the referrals
#for (i in 1:nrow(FO_names)) {
#  dir_path <- paste0("referral/", FO_names[i, 1])
#
#  if (!dir.exists(dir_path)) {
#    dir.create(dir_path, recursive = TRUE)
#  }
#
#}
# Function to write or append data to Excel
write_or_append_excel <- function(data, fo_name, output_dir) {
# Construct the file path
file_path <- file.path(output_dir, paste0("referral/", fo_name, "_contact_data.xlsx"))
# If the file exists, append the data
if (file.exists(file_path)) {
# Load the existing workbook
wb <- loadWorkbook(file_path)
# Read the existing data from the first sheet (assumed)
existing_data <- read.xlsx(file_path, sheet = 1)
# Combine existing data with the new data
combined_data <- bind_rows(existing_data, data)
# Clear the sheet and write combined data
removeWorksheet(wb, 1)  # Remove the old sheet
addWorksheet(wb, "Sheet1")  # Add a new sheet
writeData(wb, sheet = "Sheet1", combined_data)  # Write combined data
# Save the workbook
saveWorkbook(wb, file_path, overwrite = TRUE)
} else {
# If the file doesn't exist, create a new Excel file
wb <- createWorkbook()
addWorksheet(wb, "Sheet1")
writeData(wb, sheet = "Sheet1", data)
# Save the workbook
saveWorkbook(wb, file_path)
}
}
# Iterate over the list of data frames and save them
purrr::walk(contact_data_by_fo, ~ {
fo_name <- unique(.$Responsible_FO)  # Extract the Responsible_FO name
write_or_append_excel(., fo_name, output_dir = getwd())  # Call the function to write or append to Excel
})
contact_data_by_fo
group_by_fo <- df %>%
dplyr::group_by(Responsible_FO)
group_by_fo
group_by_fo %>% filter(Responsible_FO == "No_FO")
df <- df %>%
left_join(field_officer_location, by = join_by(idp_code == `CCCM IDP Site Code`))
df %>% filter(Responsible_FO == "No_FO")
df <- df %>%
left_join(field_officer_location, by = join_by(idp_code == `CCCM IDP Site Code`))
df$Responsible_FO
user_login <- Sys.info()[["user"]]
wd_path <- sprintf(r"(C:/Users/%s/ACTED/IMPACT SOM - 02_Research/01_REACH/Team - Displacement to Durable Solutions (DDS)/03_DDSU/SOMXX_DSA/03_Data_Analysis/DSA_VIII_Scripts)", user_login)
setwd(wd_path)
if (access_from_server == TRUE) {
source(sprintf(r"(C:\Users\%s\ACTED\IMPACT SOM - 02_Research\01_REACH\Data Team\02_Functions\access_kobo_api.r)", user_login))
df <- get_kobo_data(asset_id = "a38DR4AhAH2rDqP6e5YHLm")
print("Kobo data successfully accessed from server")
} else {
df <- readxl::read_excel(r"(input/SOM2204_CCCM_DSA_July.xlsx)") ###### remove this once no longer required ###############
district_file <- read.csv("input/idp_list.csv")
koboToolPath = "input/tool/REACH_2023_SOM_DSA_Survey_Tool.xlsx"
questions = import(koboToolPath,sheet="survey") %>%
filter(!is.na(name))
choices = import(koboToolPath,sheet="choices")
}
site_path <- sprintf(r"(C:\Users\%s\ACTED\IMPACT SOM - 02_Research\01_REACH\Team - Displacement to Durable Solutions (DDS)\03_DDSU\SOMXX_DSA\01_Research_Design\Reference_Data\idp-site-master-list-sep-2024.xlsx)", user_login)
site_data <- read_excel(site_path, sheet = "Sites for Field") %>%
mutate(District = str_to_title(District))
## read in FO site and locations
fo_base_assingment_str <- sprintf(r"(C:\Users\%s\ACTED\IMPACT SOM - 02_Research\01_REACH\Team - Displacement to Durable Solutions (DDS)\03_DDSU\SOMXX_DSA\03_Data_Analysis\DSA_VIII_Scripts\input/Field team work distribution.xlsx)", user_login)
fo_district_mapping <- read_excel(fo_base_assingment_str) %>%
mutate(Locations = str_to_title(Locations))
field_officer_location <- site_data %>%
left_join(fo_district_mapping, by = join_by("District" == "Locations")) %>%
distinct(`CCCM IDP Site Code`, District, Responsible_FO) %>%
mutate(Responsible_FO = str_replace_all(Responsible_FO, "/", "_"),
Responsible_FO = ifelse(Responsible_FO == "" | is.na(Responsible_FO), "No_FO", Responsible_FO)) %>%
filter(!is.na(`CCCM IDP Site Code`))
field_officer_location$Responsible_FO <- ifelse(field_officer_location$Responsible_FO == "" | is.na(field_officer_location$Responsible_FO), "No_FO", field_officer_location$Responsible_FO)
dynamic_date <- FALSE
args <- commandArgs(trailingOnly = T)
print(args)
date_selection <- args[1]
if (length(args) == 2) {
custom_date_option <- args[2]
}
#if (dynamic_date) {
#  date_selection <- menu(c("Yesterday's date", "Today's date", "Specific date"),
#                         title = "Choose the date for which you want to clean data", graphics = TRUE)
if (dynamic_date) {
if (date_selection == "1" || date_selection == "yesterday") {
date_to_filter <- Sys.Date() - 1
message("You selected yesterday's date.")
} else if (date_selection == "today") {
date_to_filter <- Sys.Date()
message("You selected today's date.")
} else if (custom_date_option == 3) {
specific_date <- args[1]
date_to_filter <- as.Date(specific_date)
print("Date successfully filtered!")
} else {
stop("Invalid selection or exit chosen.")
}
print(date_to_filter)
df <- df %>%
left_join(district_file, by = c("idp_code")) %>%
mutate(submission_date = format(ymd_hms(`_submission_time`), "%Y-%m-%d")) %>%
filter(submission_date == date_to_filter)
} else {
df <- df %>%
left_join(district_file, by = c("idp_code")) %>%
mutate(submission_date = format(ymd_hms(`_submission_time`), "%Y-%m-%d")) %>%
filter(submission_date == "2023-10-08")
}
if (nrow(df) == 0) {
stop("Data ingested is empty")
}
## add a flag for whether there is a referral included for later
df <- df %>%
mutate(referral_yn = case_when(
str_starts(referral_person, "Yes") ~ "Yes",
str_starts(referral_person, "No") ~ "No",
TRUE ~ NA_character_
))
tool.survey<- questions%>%
filter(name%in%colnames(df))
cols.integer <- tool.survey %>%
filter(type == "integer") %>%
pull(name)
cols.gps <- tool.survey %>%
filter(type == "gps") %>%
pull(name)
cols.characters_one <- tool.survey %>%
filter(str_detect(type, "select_one")) %>%
pull(name)
cols.characters_multiple <- tool.survey %>%
filter(str_detect(type, "select_multiple")) %>%
pull(name)
df <- mutate_at(df, cols.gps, as.integer)
df <- mutate_at(df, cols.integer, as.integer)
df <- mutate_at(df, cols.characters_one, as.character)
df <- mutate_at(df, cols.characters_multiple, as.character)
time_check <- function(df, time_min, time_max){
df <- df %>% mutate(interview_duration = difftime(as.POSIXct(ymd_hms(end)), as.POSIXct(ymd_hms(start)), units = "mins"),
CHECK_interview_duration = case_when(
interview_duration < time_min ~ "Too short",
interview_duration > time_max ~ "Too long",
TRUE ~ "Okay"
)
)
return(df)
}
"%!in%" <- Negate("%in%")
df <- time_check(df, time_min = mindur, time_max = maxdur)
gis_data <- df %>%
filter(interview_duration>=30 & consent=="yes") %>%
select(uuid,start,end,audit,today,enum_name,localisation_region_label,
ki_contact,district_name,idp_code,IDP_Site,contains("gps"),more_info)
gis_master <- readxl::read_excel("gis/gis_master_DSA_VII.xlsx") ## NEEDS UPDATING
gis_data  <- filter(gis_data, uuid %!in% gis_master$uuid)
gis_master <- rbind(gis_data,gis_master)
gis_master <- gis_master [!duplicated(gis_master$uuid),]
#write.xlsx(gis_master,paste("C:\\Users\\aaron.langat\\Documents\\R\\01_DSA\\03_Cleaning\\gis/gis_master.xlsx"))
gis_data <- gis_data [!duplicated(gis_data$uuid),]
n_occur_idp_code <- df %>%
dplyr::count(idp_code) %>%
filter(n > 4)
count_ki_roles_site <- df %>%
group_by(idp_code,ki_role) %>%
dplyr::summarise(n=n()) %>%
filter(n > 1)
check_list <- data.frame(
name = c(
"KI_Consent",
"KI_too_old",
"KI_age_and_role",
"IDP_arrival_time",
"ki_role_camp_structure",
"ki_role_resident",
"small_camp",
"small_families",
"low_number_of_individuals",
"idp_code_count",
"ki_role_per_site"),
check = c(
r"(consent == "no")",
"ki_age == \"90_above\"",
r"((ki_age=="30_49" | ki_age=="18_29") & ki_role=="elder")",
r"((duration_site_established_in_months < 4 & cccm_idps_arrival=="morethansixmonths" | cccm_idps_arrival=="fourtosixmonths")|
(duration_site_established_in_months < 2 & cccm_idps_arrival=="morethansixmonths" | cccm_idps_arrival=="fourtosixmonths"|cccm_idps_arrival=="onetothreemonths")|
(duration_site_established_in_months < 6 & cccm_idps_arrival=="morethansixmonths"))",
r"(ki_role %in% c("gatekeeper", "camp_leader", "site_manager") & camp_structure == "no")",
r"(ki_role == "site_resident" & ki_resident == "no")",
r"(cccm_populationestimates_shelters < 50)",
r"(cccm_populationestimates_families < 100)",
r"(cccm_populationestimates_individuals < 150)",
r"(idp_code %in% n_occur_idp_code$idp_code)",
r"(idp_code %in% count_ki_roles_site$idp_code)"
),
description = c(
"KI has not given consent. Please review why.",
"KI respondent has said they are older than 90. Please check",
"KI age is is less than 50 and his role is an elder",
"IDPs claim they have arrived before the site was set up",
"KI has already identifed him/here self as site manager or gatekeeper, but is reporting that no camp structure exists, please confirm",
"KI has reported their role is site resident but separately said they are not a site resident. Please review with the enumerator.",
"The number shelters in the camp are less then 50, please confirm with enumerator",
"The number of families in the camp are less than 100, please confirm with enumeator",
"The number of individuals in the camp is less than 150. Please confirm with the enumerator",
"The IDP Site has been interviewed more than four times. Please verify.",
"The same role has been interviewed in an IDP site more than once. Please verify"
),
columns_to_clean = c(
"consent",
"ki_age",
"ki_age, ki_role",
"duration_site_established_in_months, cccm_idps_arrival",
"ki_role, camp_structure",
"ki_role, ki_resident",
"cccm_populationestimates_shelters",
"cccm_populationestimates_families",
"cccm_populationestimates_individuals",
"idp_code",
"idp_code"
)
)
outlier_excluded_questions <- questions %>%
filter(type != 'integer') %>%
pull(name) %>%
unique()
# intersect between the dataset and the kobo tool questions to make sure we get a clean list
excluded_questions_in_data <- intersect(colnames(df), outlier_excluded_questions)
df %>%
left_join(field_officer_location, by = join_by(idp_code == `CCCM IDP Site Code`)) %>% filter(is.na(Responsible_FO ))
df %>% filter(idp_code %!in% field_officer_location$`CCCM IDP Site Code`)
df %>% filter(idp_code %!in% field_officer_location$`CCCM IDP Site Code`) %>% write_csv('sites_not_in_list.csv')
df %>% filter(idp_code %!in% field_officer_location$`CCCM IDP Site Code`)
df %>% filter(idp_code %!in% field_officer_location$`CCCM IDP Site Code`) %>% select(idp_site)
df %>% filter(idp_code %!in% field_officer_location$`CCCM IDP Site Code`) %>% select(IDP_Site)
field_officer_location$District
df$district_name
df <- df %>%
left_join(field_officer_location, by = join_by(district_name == district))
access_from_server <- FALSE
###################################################
###### STEP 2 - IMPORT DATA AND FUNCTIONS #########
###################################################
user_login <- Sys.info()[["user"]]
wd_path <- sprintf(r"(C:/Users/%s/ACTED/IMPACT SOM - 02_Research/01_REACH/Team - Displacement to Durable Solutions (DDS)/03_DDSU/SOMXX_DSA/03_Data_Analysis/DSA_VIII_Scripts)", user_login)
setwd(wd_path)
if (access_from_server == TRUE) {
source(sprintf(r"(C:\Users\%s\ACTED\IMPACT SOM - 02_Research\01_REACH\Data Team\02_Functions\access_kobo_api.r)", user_login))
df <- get_kobo_data(asset_id = "a38DR4AhAH2rDqP6e5YHLm")
print("Kobo data successfully accessed from server")
} else {
df <- readxl::read_excel(r"(input/SOM2204_CCCM_DSA_July.xlsx)") ###### remove this once no longer required ###############
district_file <- read.csv("input/idp_list.csv")
koboToolPath = "input/tool/REACH_2023_SOM_DSA_Survey_Tool.xlsx"
questions = import(koboToolPath,sheet="survey") %>%
filter(!is.na(name))
choices = import(koboToolPath,sheet="choices")
}
access_from_server <- FALSE
###################################################
###### STEP 2 - IMPORT DATA AND FUNCTIONS #########
###################################################
user_login <- Sys.info()[["user"]]
wd_path <- sprintf(r"(C:/Users/%s/ACTED/IMPACT SOM - 02_Research/01_REACH/Team - Displacement to Durable Solutions (DDS)/03_DDSU/SOMXX_DSA/03_Data_Analysis/DSA_VIII_Scripts)", user_login)
setwd(wd_path)
if (access_from_server == TRUE) {
source(sprintf(r"(C:\Users\%s\ACTED\IMPACT SOM - 02_Research\01_REACH\Data Team\02_Functions\access_kobo_api.r)", user_login))
df <- get_kobo_data(asset_id = "a38DR4AhAH2rDqP6e5YHLm")
print("Kobo data successfully accessed from server")
} else {
df <- readxl::read_excel(r"(input/SOM2204_CCCM_DSA_July.xlsx)") ###### remove this once no longer required ###############
district_file <- read.csv("input/idp_list.csv")
koboToolPath = "input/tool/REACH_2023_SOM_DSA_Survey_Tool.xlsx"
questions = import(koboToolPath,sheet="survey") %>%
filter(!is.na(name))
choices = import(koboToolPath,sheet="choices")
}
## read in site level data
site_path <- sprintf(r"(C:\Users\%s\ACTED\IMPACT SOM - 02_Research\01_REACH\Team - Displacement to Durable Solutions (DDS)\03_DDSU\SOMXX_DSA\01_Research_Design\Reference_Data\idp-site-master-list-sep-2024.xlsx)", user_login)
site_data <- read_excel(site_path, sheet = "Sites for Field") %>%
mutate(District = str_to_title(District))
## read in FO site and locations
fo_base_assingment_str <- sprintf(r"(C:\Users\%s\ACTED\IMPACT SOM - 02_Research\01_REACH\Team - Displacement to Durable Solutions (DDS)\03_DDSU\SOMXX_DSA\03_Data_Analysis\DSA_VIII_Scripts\input/Field team work distribution.xlsx)", user_login)
fo_district_mapping <- read_excel(fo_base_assingment_str) %>%
mutate(Locations = str_to_title(Locations))
field_officer_location <- site_data %>%
left_join(fo_district_mapping, by = join_by("District" == "Locations")) %>%
distinct(`CCCM IDP Site Code`, District, Responsible_FO) %>%
mutate(Responsible_FO = str_replace_all(Responsible_FO, "/", "_"),
Responsible_FO = ifelse(Responsible_FO == "" | is.na(Responsible_FO), "No_FO", Responsible_FO)) %>%
filter(!is.na(`CCCM IDP Site Code`))
field_officer_location$Responsible_FO <- ifelse(field_officer_location$Responsible_FO == "" | is.na(field_officer_location$Responsible_FO), "No_FO", field_officer_location$Responsible_FO)
#############load datasets ##################
## example date "2023-10-08T07:56:32"
dynamic_date <- FALSE
args <- commandArgs(trailingOnly = T)
print(args)
date_selection <- args[1]
if (length(args) == 2) {
custom_date_option <- args[2]
}
#if (dynamic_date) {
#  date_selection <- menu(c("Yesterday's date", "Today's date", "Specific date"),
#                         title = "Choose the date for which you want to clean data", graphics = TRUE)
if (dynamic_date) {
if (date_selection == "1" || date_selection == "yesterday") {
date_to_filter <- Sys.Date() - 1
message("You selected yesterday's date.")
} else if (date_selection == "today") {
date_to_filter <- Sys.Date()
message("You selected today's date.")
} else if (custom_date_option == 3) {
specific_date <- args[1]
date_to_filter <- as.Date(specific_date)
print("Date successfully filtered!")
} else {
stop("Invalid selection or exit chosen.")
}
print(date_to_filter)
df <- df %>%
left_join(district_file, by = c("idp_code")) %>%
mutate(submission_date = format(ymd_hms(`_submission_time`), "%Y-%m-%d")) %>%
filter(submission_date == date_to_filter)
} else {
df <- df %>%
left_join(district_file, by = c("idp_code")) %>%
mutate(submission_date = format(ymd_hms(`_submission_time`), "%Y-%m-%d")) %>%
filter(submission_date == "2023-10-08")
}
if (nrow(df) == 0) {
stop("Data ingested is empty")
}
## add a flag for whether there is a referral included for later
df <- df %>%
mutate(referral_yn = case_when(
str_starts(referral_person, "Yes") ~ "Yes",
str_starts(referral_person, "No") ~ "No",
TRUE ~ NA_character_
))
tool.survey<- questions%>%
filter(name%in%colnames(df))
####### CONVERT COLUMNS TO REQUIRED DATA TYPE  #####
cols.integer <- tool.survey %>%
filter(type == "integer") %>%
pull(name)
cols.gps <- tool.survey %>%
filter(type == "gps") %>%
pull(name)
cols.characters_one <- tool.survey %>%
filter(str_detect(type, "select_one")) %>%
pull(name)
cols.characters_multiple <- tool.survey %>%
filter(str_detect(type, "select_multiple")) %>%
pull(name)
df <- mutate_at(df, cols.gps, as.integer)
df <- mutate_at(df, cols.integer, as.integer)
df <- mutate_at(df, cols.characters_one, as.character)
df <- mutate_at(df, cols.characters_multiple, as.character)
#######
# cols.integer <- filter(tool.survey, type=="calculate")$name
# df <- mutate_at(df, cols.integer, as.integer)
#
# #convert select_one to character
########################################################
########### STEP 3 -- CLEAN THE DATA ###################
########################################################
time_check <- function(df, time_min, time_max){
df <- df %>% mutate(interview_duration = difftime(as.POSIXct(ymd_hms(end)), as.POSIXct(ymd_hms(start)), units = "mins"),
CHECK_interview_duration = case_when(
interview_duration < time_min ~ "Too short",
interview_duration > time_max ~ "Too long",
TRUE ~ "Okay"
)
)
return(df)
}
"%!in%" <- Negate("%in%")
df <- time_check(df, time_min = mindur, time_max = maxdur)
n_occur_idp_code <- df %>%
dplyr::count(idp_code) %>%
filter(n > 4)
count_ki_roles_site <- df %>%
group_by(idp_code,ki_role) %>%
dplyr::summarise(n=n()) %>%
filter(n > 1)
check_list <- data.frame(
name = c(
"KI_Consent",
"KI_too_old",
"KI_age_and_role",
"IDP_arrival_time",
"ki_role_camp_structure",
"ki_role_resident",
"small_camp",
"small_families",
"low_number_of_individuals",
"idp_code_count",
"ki_role_per_site"),
check = c(
r"(consent == "no")",
"ki_age == \"90_above\"",
r"((ki_age=="30_49" | ki_age=="18_29") & ki_role=="elder")",
r"((duration_site_established_in_months < 4 & cccm_idps_arrival=="morethansixmonths" | cccm_idps_arrival=="fourtosixmonths")|
(duration_site_established_in_months < 2 & cccm_idps_arrival=="morethansixmonths" | cccm_idps_arrival=="fourtosixmonths"|cccm_idps_arrival=="onetothreemonths")|
(duration_site_established_in_months < 6 & cccm_idps_arrival=="morethansixmonths"))",
r"(ki_role %in% c("gatekeeper", "camp_leader", "site_manager") & camp_structure == "no")",
r"(ki_role == "site_resident" & ki_resident == "no")",
r"(cccm_populationestimates_shelters < 50)",
r"(cccm_populationestimates_families < 100)",
r"(cccm_populationestimates_individuals < 150)",
r"(idp_code %in% n_occur_idp_code$idp_code)",
r"(idp_code %in% count_ki_roles_site$idp_code)"
),
description = c(
"KI has not given consent. Please review why.",
"KI respondent has said they are older than 90. Please check",
"KI age is is less than 50 and his role is an elder",
"IDPs claim they have arrived before the site was set up",
"KI has already identifed him/here self as site manager or gatekeeper, but is reporting that no camp structure exists, please confirm",
"KI has reported their role is site resident but separately said they are not a site resident. Please review with the enumerator.",
"The number shelters in the camp are less then 50, please confirm with enumerator",
"The number of families in the camp are less than 100, please confirm with enumeator",
"The number of individuals in the camp is less than 150. Please confirm with the enumerator",
"The IDP Site has been interviewed more than four times. Please verify.",
"The same role has been interviewed in an IDP site more than once. Please verify"
),
columns_to_clean = c(
"consent",
"ki_age",
"ki_age, ki_role",
"duration_site_established_in_months, cccm_idps_arrival",
"ki_role, camp_structure",
"ki_role, ki_resident",
"cccm_populationestimates_shelters",
"cccm_populationestimates_families",
"cccm_populationestimates_individuals",
"idp_code",
"idp_code"
)
)
############ data cleaning ############
outlier_excluded_questions <- questions %>%
filter(type != 'integer') %>%
pull(name) %>%
unique()
# intersect between the dataset and the kobo tool questions to make sure we get a clean list
excluded_questions_in_data <- intersect(colnames(df), outlier_excluded_questions)
df <- df %>%
left_join(field_officer_location, by = join_by(district_name == district))
df <- df %>%
left_join(field_officer_location, by = join_by(idp_code == `CCCM IDP Site Code`))
